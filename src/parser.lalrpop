use ast::NodeRef;
use ast::OptNodeRef;
use ast::CpathType;
use lexer::Lexer;
use lexer::LexerState
use lexer::Tok;
use lalrpop_util::ParseError;

#[LALR]
grammar<'state>(p: &mut Lexer<'state>);

extern {
  type Location = lexer::Location;
  type Error = lexer::LexerError;

  enum lexer::Tok<'input> {
    "alias" => Tok::Alias,
    "undef" => Tok::Undef,
    "BEGIN" => Tok::BEGIN,
    "END" => Tok::BEGIN,

    "{" => Tok::Char('{'),
    "}" => Tok::Char('}'),
    "=" => Tok::Char('='),
    "!" => Tok::Char('!'),
    "[" => Tok::Char('['),
    "]" => Tok::Char(']'),
    "," => Tok::Char(','),
    "|" => Tok::Char('|'),
    "^" => Tok::Char('^'),
    "&" => Tok::Char('&'),
    "<=>" => Tok::Cmp,
    "==" => Tok::Eq,
    "===" => Tok::Eqq,
    "=~" => Tok::Match,
    "!~" => Tok::NMatch,
    ">" => Tok::Char('>'),
    ">=" => Tok::GEq,
    "<" => Tok::Char('<'),
    "<=" => Tok::LEq,
    "!=" => Tok::NEq,
    "<<" => Tok::LShift,
    ">>" => Tok::RShift,
    "+" => Tok::Char('+'),
    "-" => Tok::Char('-'),
    "*" => Tok::Char('*'),
    "/" => Tok::Char('/'),
    "%" => Tok::Char('%'),
    "**" => Tok::Pow,
    "~" => Tok::Char('~'),
    "+@" => Tok::UPlus,
    "-@" => Tok::UMinus,
    "[]" => Tok::ARef,
    "[]=" => Tok::ASet,
    "`" => Tok::Char('`'),
    "&&" => Tok::AndOp,
    "||" => Tok::OrOp,
    "?" => Tok::Char('?'),
    ":" => Tok::Char(':'),
    "(" => Tok::Char('('),
    ")" => Tok::Char(')'),
    "amper" => Tok::Amper,
    "lparen_arg" => Tok::LparenArg,
    "lbrack" => Tok::Lbrack,
    "->" => Tok::Lambda,
    ";" => Tok::Char(';'),
    "=>" => Tok::Assoc,
    "." => Tok::Char('.'),
    "&." => Tok::AndDot,
    "\n" => Tok::NewLine,

    "lambeg" => Tok::Lambeg,

    "char" => Tok::Char(<String>),
    "string" => Tok::String(<String>),
    "string_beg" => Tok::StringBeg,
    "string_mid" => Tok::StringMid(<Symbol>),
    "string_part" => Tok::StringPart(<String>),
    "literal_delim" => Tok::LiteralDelim,
    "hd_literal_delim" => Tok::HdLiteralDelim,
    "xstring_beg" => Tok::XStringBeg,
    "xstring" => Tok::XString(<String>),
    "regexp_beg" => Tok::RegexpBeg,
    "regexp" => Tok::Regexp(<String>),
    "heredoc_beg" => Tok::HeredocBeg,
    "heredoc_end" => Tok::HeredocEnd,
    "hd_string_mid" => Tok::HdStringMid(<String>),
    "hd_start_part" => Tok::HdStartPart(<String>),
    "words_beg" => Tok::WordsBeg,
    "symbeg" => Tok::SymBeg,
    "symbols_beg" => Tok::SymbolsBeg,
    "label_end" => Tok::LabelEnd(<Symbol>),

    "nth_ref" => Tok::NthRef,
    "back_ref" => Tok::BackRef,

    "__LINE__" => Tok::Line,
    "__FILE__" => Tok::File,
    "__ENCODING__" => Tok::Encoding,

    "op_asgn" => Tok::op_asgn(<Symbol>),
    "ident" => Tok::Ident(<Symbol>),
    "fid" => Tok::FID(<Symbol>),
    "gvar" => Tok::GVar(<Symbol>),
    "ivar" => Tok::IVar(<Symbol>),
    "const" => Tok::Const(<Symbol>),
    "cvar" => Tok::CVar(<Symbol>),
    "label" => Tok::Label(<Symbol>),

    "uminus_num" => Tok::UMinusNum,
    "uplus" => Tok::UPlus,
    "uminus" => Tok::UMinus,
    "integer" => Tok::Integer(u32),
    "float" => Tok::Float(float),

    "colon2" => Tok::Colon2,
    "colon3" => Tok::Colon3,
    ".." => Tok::Dot2,
    "..." => Tok::Dot3,

    "mod_if" => Tok::ModifierIf,
    "mod_unless" => Tok::ModifierUnless,
    "mod_while" => Tok::ModifierWhile,
    "mod_until" => Tok::ModifierUntil,
    "mod_rescue" => Tok::ModifierRescue,

    "and" => Tok::And,
    "or" => Tok::Or,
    "not" => Tok::Not,
    "super" => Tok::Super,
    "yield" => Tok::Yield,
    "return" => Tok::Return,
    "break" => Tok::Break,
    "next" => Tok::Next,
    "begin" => Tok::Begin,
    "case" => Tok::Case,
    "class" => Tok::Class,
    "def" => Tok::Def,
    "do" => Tok::Do,
    "do_cond" => Tok::DoCond,
    "do_LAMBDA" => Tok::DoLambda,
    "do_block" => Tok::DoBlock,
    "else" => Tok::Else,
    "elsif" => Tok::Elsif,
    "end" => Tok::End,
    "ensure" => Tok::Ensure,
    "false" => Tok::False,
    "for" => Tok::For,
    "in" => Tok::In,
    "module" => Tok::Module,
    "nil" => Tok::Nil,
    "redo" => Tok::Redo,
    "rescue" => Tok::Rescue,
    "retry" => Tok::REtry,
    "self" => Tok::Self,
    "then" => Tok::Then,
    "true" => Tok::True,
    "undef" => Tok::Undef,
    "when" => Tok::When,
    "if" => Tok::If,
    "unless" => Tok::Unless,
    "while" => Tok::While,
    "until" => Tok::Until,

    "lbrace_arg" => Tok::LbraceArg,
    "star" => Tok::Star,
    "lparen" => Tok::Lparen,
  }
}

pub Program: NodeRef = { TopStmts };

TopStmts: BeginNodeRef = {
  <stmts:(<TopStmt> Term+)*> <t:TopStmt?> => match t {
    Some(t) => { stmts.push(t); stmts },
    None => stmts,
  },
  ! <t:TopStmt> => p.new_begin(None),
};

TopStmt: NodeRef = {
  Stmt,
  "BEGIN" "{" TopStmts "}" => Err("BEGIN not supported"),
};

Bodystmt: NodeRef = {
  <c:Compstmt> <r:Rescue?> <el:Else?> <en:("ensure" <Compstmt>)?> =>
    p.new_bodystmt(c, r, el, en),
};

Compstmt: Vec<NodeRef> = { Stmts };

Stmts: Vec<NodeRef> = {
  <res:(<Stmt> Term+)*> <s:Stmt?> => match s {
    Some(s) => { res.push(s); res }
    None => res
  },
  ! <s:Stmt> => vec![s],
};

StmtNoMod: NodeRef = {
  "alias" <a:AliasFsym> <f:Fsym> => p.new_alias(a, f),
  "undef" <l:UndefList> => p.new_undef(l),
  CommandAsgn,
  "END" "{" <s:Compstmt> "}" => Err("END not supported"),
  <l:Mlhs> "=" <c:CommandCall> => p.new_masgn(l, c),
  <l: Lhs> "=" <r:Mrhs> => p.new_asgn(l, p.new_array(r)),
  <l:Mlhs> "=" <a:Arg> => p.new_masgn(l, a),
  <l:Mlhs> "=" <r:Mrhs> => p.new_masgn(l, p.new_array(r)),
  Expr,
};

Stmt: NodeRef = {
  <s:StmtNoMod> "mod_if" <e:StmtNoMod> => p.new_if(p.cond(e) s, None),
  <s:StmtNoMod> "mod_unless" <e:StmtNoMod> => p.new_unless(p.cond(e), s, None),
  <s:StmtNoMod> "mod_while" <e:StmtNoMod> => p.new_while(p.cond(e), s),
  <s:StmtNoMod> "mod_until" <e:StmtNoMod> => p.new_until(p.cond(e), s),
  // <s:Stmt> "mod_rescue" <r:StmtNoMod> => p.new_mod_rescue(s, r),
  StmtNoMod,
};

AliasFsym: Symbol = {
  Fsym => { p.lstate = LexerState::FNAME; <> }
};

CommandAsgn: NodeRef = {
  <l:Lhs> "=" <r:CommandRhs> => p.new_asgn(l, r),
  <l:VarLhs> <op:"op_asgn"> <r:CommandRhs> => p.new_op_asgn(l, op, r),
  <prim:Primary> "[" <idx:OptCallArgs> Rbracket <op:"op_asgn"> <r:CommandRhs> =>
    p.new_op_asgn(p.new_call(prim, Symbol::from("[]"), idx, '.'), op, r),
  <prim:Primary> <c:CallOp> <id:"ident"> <op:"op_asgn"> <r:CommandRhs> =>
    p.new_op_asgn(p.new_call(prim, id, vec![], c), op, r),
  <prim:Primary> <c:CallOp> <id:"const"> <op:"op_asgn"> <r:CommandRhs> =>
    p.new_op_asgn(p.new_call(prim, id, vec![], c), op, r),
  Primary "colon2" "const" "op_asgn" CommandCall =>
    Err("constant re-assignment"),
  <prim:Primary> "colon2" <id:"ident"> <op:"op_asgn"> <r:CommandRhs> =>
    p.new_op_asgn(p.new_call(prim, id, vec![], Tok::colon2), op, r),
  <b:Backref> <op:"op_asgn"> CommandRhs => p.backref_error(b),
};

CommandRhs: NodeRef = {
  CommandCall, // %prec "op_asgn"
  <c:StmtNoMod> "mod_rescue" <s:CommandCall> => p.new_mod_rescue(c, s),
  CommandAsgn,
};

ExprNot: NodeRef = {
  "not" Nl? <e:Arg> => p.call_uni_op(p.cond(e), "!"),
};

ExprAndOr: NodeRef = {
  <l:ExprAndOr> "and" <r:ExprNot> => p.new_and(l, r),
  <l:ExprAndOr> "or" <r:ExprNot> => p.new_or(l, r),
  ExprNot,
};

Expr: NodeRef = {
  CommandCall,
  ExprAndOr,
  "!" <c:CommandCall> => p.call_uni_op(p.cond(c), "!"),
};

CommandCall: NodeRef = { Command, BlockCommand };

BlockCommand: NodeRef = {
  BlockCall,
  <b:BlockCall> <c:CallOp2> <o:Operation2> <args:CommandArgs> =>
    p.new_call(b, c, o, args),
};

CmdBraceBlock: NodeRef = {
  CmdBraceBlockBegin <b:OptBlockParam> <c:Compstmt> "}" => {
    let ret = p.new_block(b, c);
    p.local_unnest();
    ret
  }
};

CmdBraceBlockBegin: () = { "lbrace_arg" => p.local_nest() };

Command: NodeRef = {
  <op:Operation> <c:CommandArgs> <b:CmdBraceBlock> => {
    match b { Some(b) => { p.args_with_block(c, b); }, _ => {} };
    p.new_fcall(op, c)
  },
  <prim:Primary> <c_op:CallOp> <op:Operation2> <c:CommandArgs> <b:CmdBraceBlock?> => {
    match b { Some(b) => { p.args_with_block(c, b); }, _ => {} };
    p.new_call(prim, op, c, c_op)
  },
  <prim:Primary> "colon2" <op:Operation2> <c:CommandArgs> <b:CmdBraceBlock?> => {
    match b { Some(b) => { p.args_with_block(c, b); }, _ => {} };
    p.new_call(prim, op, c, Symbol::from("::"))
  },
  "super" <c:CommandArgs> => p.new_super(c),
  "yield" <c:CommandArgs> => p.new_yield(c),
  "return" <c:CallArgs> => p.new_return(p.ret_args(c)),
  "break" <c:CallArgs> => p.new_break(p.ret_args(c)),
  "next" <c:CallArgs> => p.new_next(p.ret_args(c)),
};

Mlhs: Vec<NodeRef> = {
  MlhsBasic,
  "lparen" <MlhsInner> Rparen => <>,
};

MlhsInner: Vec<NodeRef> = {
  MlhsBasic,
  "lparen" <MlhsInner> Rparen => <>,
};

MlhsBasic: (Vec<NodeRef>, Option<OptNodeRef>, Vec<NodeRef>) = {
  <pre:(<MlhsItem> ",")*> <n:("star" <Lhs?>)> <post:("," <MlhsItem>)*> => (pre, Some(n), post),
  <l:(<MlhsItem> ",")+> <i:MlhsItem?> => {
    match i => { Some(i) => { l.push(i); }, _ => {} };
    (l, None, vec![])
  },
};

#[inline]
MlhsItem: NodeRef = {
  Lhs,
  "lparen" <MlhsInner> Rparen => p.new_masgn(<>, vec![]),
};

#[inline]
Lhs: NodeRef = {
  Variable => p.assignable(<>),
  <prim:Primary> "[" <c:OptCallArgs> Rbracket =>
    p.new_call(prim, Symbol::from(""), c, Symbol::from(".")),
  <prim:Primary> <c_op:CallOp> <id:"ident"> =>
    p.new_call(prim, id, vec![], c_op),
  <prim:Primary> "colon2" <id:"ident"> =>
    p.new_call(prim, id, vec![], Symbol::from("::")),
  <prim:Primary> <c_op:CallOp> <id:"const"> =>
    p.new_call(prim, id, vec![], c_op),
  <prim:Primary> "colon2" <id:"const"> => {
    if (p.in_def || p.in_single)
      return Err("dynamic constant assignment");
    p.new_colon2(prim, id, vec![], Symbol::from("::"))
  },
  "colon3" <id:"const"> => {
    if (p.in_def || p.in_single)
      return Err("dynamic constant assignment");
    p.new_colon3(id)
  },
  // <b:Backref> => p.backref_error(b),
};

Cname: Symbol = {
  "ident" => Err("class/module name must be CONSTANT"),
  "const",
};

Cpath: (CpathType, Symbol) = {
  "colon3" <Cname> => (Absolute, <>),
  Cname => (Relative, <>),
  <prim:Primary> "colon2" <c:Cname> => (Expression(prim), c),
};

Fname: Symbol = {
  "ident", "const", "fid",
  Op => { p.lstate = LexerState::ENDFN; <> },
  Reswords => {  p.lstate = LexerState::ENDFN; <> },
};

Fsym: Symbol = { Fname, BasicSymbol };

UndefList: Vec<Symbol> = {
  <l:(<Fsym> UndefListComma)*> <f:Fsym> => { l.push(f); l }
};

UndefListComma: () = { "," => { p.lstate = LexerState::FNAME; } };

Op: Symbol = {
  "|" => Symbol::from("|"),
  "^" => Symbol::from("^"),
  "&" => Symbol::from("&"),
  "<=>" => Symbol::from("<=>"),
  "==" => Symbol::from("=="),
  "===" => Symbol::from("==="),
  "=~" => Symbol::from("=~"),
  "!~" => Symbol::from("!~"),
  ">" => Symbol::from(">"),
  ">=" => Symbol::from(">="),
  "<" => Symbol::from("<"),
  "<=" => Symbol::from("<="),
  "!=" => Symbol::from("!="),
  "<<" => Symbol::from("<<"),
  ">>" => Symbol::from(">>"),
  "+" => Symbol::from("+"),
  "-" => Symbol::from("-"),
  "*" => Symbol::from("*"),
  "star" => Symbol::from("*"),
  "/" => Symbol::from("/"),
  "%" => Symbol::from("%"),
  "**" => Symbol::from("**"),
  "!" => Symbol::from("!"),
  "~" => Symbol::from("~"),
  "+@" => Symbol::from("+@"),
  "-@" => Symbol::from("-@"),
  "[]" => Symbol::from("[]"),
  "[]=" => Symbol::from("[]="),
  "`" => Symbol::from("`"),
};

Reswords: () = {
  "__LINE__", "__FILE__", "__ENCODING__", "BEGIN", "END",
  "alias", "and", "begin", "break", "case", "class", "def",
  "do", "else", "elsif", "end", "ensure", "false",
  "for", "in", "module", "next", "nil", "not", "or", "redo",
  "rescue", "retry", "return", "self",
  "super", "then", "true", "undef", "when", "yield", "if", "unless",
  "while", "until",
};

Arg1: NodeRef = {
  "!" <a:Primary> => p.call_uni_op(p.cond(a), "!"),
  "~" <a:Primary> => p.call_uni_op(p.cond(a), "~"),
  "uplus" <a:Primary> => p.call_uni_op(a, "+@"),
  Primary,
};

Arg2: NodeRef = {
  <l:Arg1> "**" <r:Arg2> => p.call_bin_op(l, "**", r),
  Arg1,
};

Arg3: NodeRef = {
  "uminus" <a:Arg2> => p.call_uni_op(a, "-@"),
  Arg2,
};

Arg4: NodeRef = {
  <l:Arg4> "*" <r:Arg3> => p.call_bin_op(l, "*", r),
  <l:Arg4> "/" <r:Arg3> => p.call_bin_op(l, "/", r),
  <l:Arg4> "%" <r:Arg3> => p.call_bin_op(l, "%", r),
  Arg3,
};

Arg5: NodeRef = {
  <l:Arg5> "+" <r:Arg4> => p.call_bin_op(l, "+", r),
  <l:Arg5> "-" <r:Arg4> => p.call_bin_op(l, "-", r),
  Arg4,
};

Arg6: NodeRef = {
  <l:Arg6> "<<" <r:Arg5> => p.call_bin_op(l, "<<", r),
  <l:Arg6> ">>" <r:Arg5> => p.call_bin_op(l, ">>", r),
  Arg5,
};

Arg7: NodeRef = {
  <l:Arg7> "&" <r:Arg6> => p.call_bin_op(l, "&", r),
  Arg6,
};

Arg8: NodeRef = {
  <l:Arg8> "|" <r:Arg7> => p.call_bin_op(l, "|", r),
  <l:Arg8> "^" <r:Arg7> => p.call_bin_op(l, "^", r),
  Arg7,
};

Arg9: NodeRef = {
  <l:Arg9> ">"  <r:Arg8> => p.call_bin_op(l, ">",  r),
  <l:Arg9> ">=" <r:Arg8> => p.call_bin_op(l, ">=", r),
  <l:Arg9> "<"  <r:Arg8> => p.call_bin_op(l, "<",  r),
  <l:Arg9> "<=" <r:Arg8> => p.call_bin_op(l, "<=", r),
  Arg8,
};

Arg10: NodeRef = {
  <l:Arg9> "<=>" <r:Arg9> => p.call_bin_op(l, "<=>", r),
  <l:Arg9> "==" <r:Arg9> => p.call_bin_op(l, "==", r),
  <l:Arg9> "===" <r:Arg9> => p.call_bin_op(l, "===", r),
  <l:Arg9> "!=" <r:Arg9> => p.call_bin_op(l, "!=", r),
  <l:Arg9> "=~" <r:Arg9> => p.call_bin_op(l, "=~", r),
  <l:Arg9> "!~" <r:Arg9> => p.call_bin_op(l, "!~", r),
  Arg9,
};

Arg11: NodeRef = {
  <l:Arg11> "&&" <r:Arg10> => p.new_and(l, r),
  Arg10,
};

Arg12: NodeRef = {
  <l:Arg12> "||" <r:Arg11> => p.new_or(l, r),
  Arg11,
};

Arg13: NodeRef = {
  <l:Arg12> ".." <r:Arg12> => p.new_dot2(l, r),
  <l:Arg12> "..." <r:Arg12> => p.new_dot3(l, r),
  Arg12,
};

Arg14: NodeRef = {
  <c:Arg13> "?" <t:Arg13> Nl? ":" <f:Arg13> => p.new_if(p.cond(c), t, f),
  Arg13,
};

ArgRhs: NodeRef = {
  Arg14, // %prec "op_asgn"
  <a:ArgRhs> "mod_rescue" <r:Arg14> => {
    p.void_expr_error(a);
    p.void_expr_error(r);
    p.new_mod_rescue(a, r)
  },
};

Arg: NodeRef = {
  <l:Lhs> "=" <r:ArgRhs> => p.new_asgn(l, r),
  <l:VarLhs> <op:"op_asgn"> <r:ArgRhs> => p.new_op_asgn(l, op, r),
  <prim:Primary> "[" <c:OptCallArgs> Rbracket <op:"op_asgn"> <r:ArgRhs> =>
    p.new_op_asgn(p.new_call(cprim, Symbol::from("[]")), op, r),
  <prim:Primary> <c_op:CallOp> <id:"ident"> <op:"op_asgn"> <r:ArgRhs> =>
    p.new_op_asgn(p.new_call(prim, id, vec![], c_op), op, r),
  <prim:Primary> <c_op:CallOp> <id:"const"> <op:"op_asgn"> <r:ArgRhs> =>
    p.new_op_asgn(p.new_call(prim, id, vec![], c_op), op, r),
  <prim:Primary> "colon2" <id:"ident"> <op:"op_asgn"> <r:ArgRhs> =>
    p.new_op_asgn(p.new_call(prim, id, vec![], Symbol::from("::"), op, r)),
  <prim:Primary> "colon2" <id:"const"> <op:"op_asgn"> <r:ArgRhs> =>
    Err("constant re-assignment"),
  "colon3" <id:"const"> <op:"op_asgn"> <r:ArgRhs> =>
    Err("constant re-assignment"),
  <b:Backref> <op:"op_asgn"> <r:Arg14> => p.backref_error(b),
  Arg14,
};

ArefArgs: Vec<NodeRef> = {
  None => vec![],
  <a:(<Arg> Comma)*> <last_a:Arg> <h:(Comma <Assoc>)*> Trailer => {
    a.push(last_a);
    a.push(p.new_hash(h));
    a
  },
  <h:(<Assoc> ",")*> <last_h:Assoc> Trailer => {
    h.push(last_h);
    vec![p.new_hash(h)]
  },
};

ParenArgs: Vec<NodeRef> = { "(" <OptCallArgs> Rparen => <> };

OptCallArgs: Vec<NodeRef> = {
  None => vec![],
  CallArgs,
  <a:(<Arg> Comma)*> <h:(<Assoc> ",")+> => { a.push(p.new_hash(h)); a },
};

CallArgs: Vec<NodeRef> = {
  Command => vec![<>],
  <a:(<Arg> Comma)*> <h:(<Assoc> ",")*> <b:BlockArg> => {
    a.push(p.new_hash(h));
    match b { Some(b) => { a.push(b); }, _ => {} };
    a
  },
  <a:(<Arg> Comma)*> <h:(<Assoc> ",")*> <last_assoc:Assoc> => {}
  <a:Args> => {}
};

CommandArgs: Vec<NodeRef> = {
  // $<stack>$ = p.cmdarg_stack;
  // CMDARG_PUSH(1);
  CallArgs
  // p.cmdarg_stack = $<stack>1;
};

BlockArg: NodeRef = { "amper" <Arg> => p.new_block_arg(<>) };

Comma: () = { "," HeredocBody* => () };

Args: Vec<NodeRef> = {
  <l:(<Arg> Comma)*> <a:Arg> => {
    p.void_expr_error(a);
    l.push(a); l
  },
  <l:(<Arg> Comma)*> "star" <a:Arg> => {
    p.void_expr_error(a);
    l.push(p.new_splat(a)); l
  },
};

Mrhs: Vec<NodeRef> = {
  <l:(<Arg> Comma)+> <a:Arg> => {
    p.void_expr_error(a);
    l.push(a); l
  },
  <l:(<Arg> Comma)*> "star" <a:Arg> => {
    p.void_expr_error(a);
    l.push(p.new_splat(a)); l
  },
};

Primary: NodeRef = {
  Literal, String, Xstring, Regexp, Heredoc, VarRef, Backref,
  <"fid"> => p.new_fcall(<>, vec![]),
  "begin" // $<stack>$ = p.cmdarg_stack; p.cmdarg_stack = 0;
    <Bodystmt>
    "end" => <>, // p.cmdarg_stack = $<stack>2;
  "lparen_arg" // $<stck>$ = p.cmdarg_stack; p.cmdarg_stack = 0;
    <Stmt> // p.lstate = LexerState::ENDARG;
    Rparen => <>, // p.cmdarg_stack = $<stack>2;
  "lparen_arg" // p.lstate = LexerState::ENDARG;
    Rparen => p.new_nil(),
  "lparen" <Compstmt> "}" => <>,
  <prim:Primary> "colon2" <id:"const"> => p.new_colon2(prim, id),
  "colon3" <"const"> => p.new_colo3(<>),
  "lbrack" <ArefArgs> "]" => p.new_array(<>),
  "return" => p.new_return(vec![]),
  "yield" <ParenArgs?> => p.new_yield(<>),
  "not" "(" <Expr> Rparen => p.call_uni_op(p.cond(<>), "!"),
  "not" "(" Rparen => p.call_uni_op(p.new_nil(), "!"),
  <op:Operation> <b:BraceBlock> => p.new_fcall(op, b),
  MethodCall,
  <m:MethodCall> <b:BraceBlock> => { p.call_with_block(m, b); m },
  "->" // p.local_nest(); $<num>$ = p->lpar_beg; p.lpar_beg = ++p->paren_nest;
    <a:FLarglist> // $<stack>$ = p.cmdarg_stack; p.cmdarg_stack = 0;
    <b:LambdaBody> => {
      // p.lpar_beg = $<num>2;
      p.new_lambda(a, b)
      // p.local_unnest(); p.cmdarg_stack = $<stack>4; CMDARG_LEXPOP();
    },
  "if" <c:Expr> Then
    <s:Compstmt>
    <t:IfTail>
    "end" => p.new_if(p.cond(c), s, t),
  "unless" <c:Expr> Then
    <s:Compstmt>
    <e:Else?>
    "end" => p.new_unless(p.cond(c), s, e),
  "while" // COND_PUSH(1);
    <c:Expr> Do // COND_POP();
    <s:Compstmt>
    <e:Else?>
    "end" => p.new_while(p.cond(c), s, e),
  "until" // COND_PUSH(1);
    <c:Expr> Do // COND_POP();
    <s:Compstmt>
    <e:Else?>
    "end" => p.new_until(p.cond(c), s, e),
  "case" <c:Expr> Term*
    <b:CaseBody>
    "end" => p.new_case(Some(c), b),
  "case" Term*
    <b:CaseBody>
    "end" => p.new_case(None(c), b),
  "for" <v:ForVar> "in" // COND_PUSH(1);
    <e:Expr> Do // COND_POP();
    <s:Compstmt>
    "end" => p.new_for(v, e, s),
  "class" <c:Cpath> <s:Superclass>
  // if p.in_def || p.in_single
  //   return Err("class definition in method body");
  // $<nd>$ = p.local_switch();
    <b:Bodystmt>
    "end" => {
      let ret = p.new_class(c, s, b);
      // p.local_resume($<nd>4);
      ret
    },
  "class" "<<" <c:Expr> // $<num>$ = p.in_def; p.in_def = 0;
    Term // $<nd>$ = cons(local_switch(p), nint(p.in_single)); p.in_single = 0;
    <s:Bodystmt>
    "end" => {
      let ret = p.new_sclass(c, s);
      // p.local_resume(p, $<nd>6->car);
      // p.in_def = $<num>4;
      // p.in_single = intn($<nd>6->cdr);
      ret
    },
  "module" <c:Cpath>
  // if p.in_def || p.in_single
  //   return Err("module definition in method body");
  // $<nd>$ = p.local_switch();
    <b:Bodystmt>
    "end" => {
      let ret = p.new_module(c, b);
      // p.local_resume($<nd>3);
      ret
    },
  "def" <f:Fname> // $<stack>$ = p.cmdarg_stack; p.cmdarg_stack = 0;
  // p.in_def++; $<nd>$ p.local_switch();
    <a:FArglist>
    <b:Bodystmt>
    "end" => {
      let ret = p.new_def(f, a, b);
      // p.local_resume(p, $<nd>4);
      // p.in_def--;
      // p.cmdarg_stack = $<stack>3;
      ret
    },
  "break" => p.new_break(vec![]),
  "next" => p.new_next(vec![]),
  "redo" => p.new_redo(),
  "retry" => p.new_retry(),
};

Then: () = { Term, "then", Term "then" };

Do: () = { Term, "do_cond" };

IfTail: OptNodeRef = {
  Else?,
  "elsif" <c:Expr> Then
    <s:Compstmt>
    <t:IfTail> => Some(p.new_if(p.cond(c), s, t)),
};

Else: NodeRef = { "else" <Compstmt> => Some(<>) };

ForVar: Vec<NodeRef> = { Lhs => vec![<>], Mlhs };

FMarg: NodeRef = {
  "ident" => p.new_arg(<>),
  "lparen" <FMargs> Rparen => p.new_masgn(<>, vec![]),
};

FMargs: (Vec<NodeRef>, Option<Option<NodeRef>>, Vec<NodeRef>) = {
  <l:(FMarg ",")*> <a:FMarg> => (<>, None, vec![]),
  <l:(<FMarg> ",")*> "star" <r:"ident"?> "," <p:("," <FMarg>)*> =>
    (match l { Some(l) => l, _ => vec![] }, Some(r),
     match p { Some(p) => p, _ => vec![] }),
};

OptBlockParam: OptNodeRef = {
  None => None,
  BlockParamDef => {
    p.cmd_start = TRUE;
    <>
  },
};

BlockParamDef: NodeRef = {
  "||" => None,
  "|" <b:FArgs> <v:Bvars?> "|" => Some(b),
};

Bvars: () = { Nl? ";" <l:(Bvar ",")*> <v:Bvar> Nl? => {} };

Bvar: () = {
  <"ident"> => {
    p.local_add_f(<>);
    p.new_bv(<>);
  },
  // FBadArg,
};

FLarglist: Vec<NodeRef> = {
  "(" <FArgs> Bvars? ")" => <>,
  FArgs,
};

LambdaBody: NodeRef = {
  "lambeg" <Compstmt> "}" => <>,
  "do_LAMBDA" <Compstmt> "end" => <>,
};

DoBlock: NodeRef = {
  "do_block" // p.local_nest();
    <o:OptBlockParam>
    <s:Compstmt>
    "end" => {
      let ret = p.new_block(o, s);
      p.local_unnest();
      ret
    },
};

BlockCall: NodeRef = {
  <c:Command> <b:DoBlock> => {
    if (c.nd_type() == NodeType::YIELD) {
      return Err("block given to yield");
    }
    p.call_with_block(c, b)
  },
  <b:BlockCall> <c_op:CallOp2> <op:Operation2> <a:ParenArgs?> =>
    p.new_call(b, op, a, c_op),
  <b:BlockCall> <c_op:CallOp2> <op:Operation2> <a:ParenArgs?> <br:BraceBlock> =>
    p.call_with_block(p.new_call(b, op, a, c_op), br),
  <b:BlockCall> <c_op:CallOp2> <op:Operation2> <a:CommandArgs> <d:DoBlock> =>
    p.call_with_block(p.new_call(b, op, a, c_op), d),
};

MethodCall: NodeRef = {
  <op:Operation> <a:ParenArgs> => p.new_fcall(op, a),
  <prim:Primary> <c_op:CallOp> <op:Operation2> <a:ParenArgs?> =>
    p.new_call(prim, op, a, c_op),
  <prim:Primary> "colon2" <op:Operation2> <a:ParenArgs> =>
    p.new_call(prim, op, a, "::"),
  <prim:Primary> "colon2" <op:Operation3> =>
    p.new_call(prim, op, vec![], "::"),
  <prim:Primary> <c_op:CallOp> <a:ParenArgs> =>
    p.new_call(prim, Symbol::from("call"), a, c_op),
  <prim:Primary> "colon2" <a:ParenArgs> =>
    p.new_call(prim, Symbol::from("call"), a, "::"),
  "super" <ParenArgs> => p.new_super(<>),
  "super" => p.new_zsuper(),
  <prim:Primary> "[" <a:OptCallArgs> Rbracket =>
    p.new_call(prim, Symbol::from("[]"), a, "."),
};

BraceBlock: NodeRef = {
  "{" // p.local_nest(); $<num>$ = p.lineno;
    <param:OptBlockParam>
    <s:Compstmt> "}" => {
      let ret = p.new_block(param, s);
      p.local_unnest();
      ret
    },
  "do" // p.local_nest(); $<num>$ = p.lineno;
    <param:OptBlockParam>
    <s:Compstmt>
    "end" => {
      let ret = p.new_block(param, s);
      p.local_unnest();
      ret;
    },
};

CaseBody: (OptNodeRef, NodeRef, OptNodeRef) = {
  "when" <a:Args> Then
    <s:Compstmt>
    <c:Cases> => (Some(a), s, Some(c))
};

Cases: (OptNodeRef, NodeRef, OptNodeRef) = {
  Else? => (None, <>, None),
  CaseBody,
};

Rescue: (Vec<NodeRef>, OptNodeRef, NodeRef, OptNodeRef) = {
  "rescue" <l:ExcList> <v:("=>" <Lhs>)?> Then
    <s:Compstmt>
    <r:Rescue?> => Some(l, v, s, r),
};

ExcList: Vec<NodeRef> = {
  Arg => vec![<>],
  Mrhs,
  None, => vec![],
};

Literal: NodeRef = { Numeric, Symbol, Words, Symbols, };

String: NodeRef = {
  "char", "string",
  "string_beg" <"string"> => <>,
  "string_beg" <r:StringRep> <s:"string"> => {
    r.push(s);
    p.new_dstr(r)
  },
};

StringRep: Vec<NodeRef> = { StringInterp+ };

StringInterp: Vec<NodeRef> = {
  <"string_mid"> => vec![<>],
  <part:"string_part"> // $<nd>$ = p.lex_strterm; p.lex_strterm = None;
    <s:Compstmt> "}" => {
      p.lex_strterm = $<nd>2;
      vec![part, s],
    },
  "literal_delim" => vec![p.new_literal_delim()],
  "hd_literal_delim"  HeredocBody+ => vec![p.new_literal_delim()],
};

Xstring: NodeRef = {
  "xstring_beg" <"xstring"> => <>,
  "xstring_beg" <r:StringRep> <s:"xstring"> => {
    r.push(s);
    p.new_dxstr(r)
  },
};

Regexp: NodeRef = {
  "regexp_beg" <"regexp"> => <>,
  "regexp_beg" <r:StringRep> <rgx:"regexp"> => p.new_dregx(r, rgx),
};

Heredoc: () = { "heredoc_beg" };

HeredocBody: () = {
  HeredocStringInterp* "heredoc_end" => {
    let inf = p.parsing_heredoc_inf();
    inf.doc.push(p.new_str(""));
    p.heredoc_end();
  },
};

HeredocStringInterp: () = {
  <"hd_string_mid"> => {
    let inf = p.parsing_heredoc_inf();
    inf.doc.push(p.new_str(<>));
    p.herdoc_treat_nextline();
  },
  <s:"hd_start_part"> // $<nd>$ = p.lex_strterm; p.lex_strterm = NULL;
    <c:Compstmt> "}" => {
      let inf = p.parsing_heredoc_inf();
      p.lex_strterm = $<nd>2;
      inf.doc.push(s);
      inf.doc.push(c);
    },
};

Words: NodeRef = {
  "words_beg" <"string"> => { p.new_words(vec![<>]) },
  "words_beg" <r:StringRep> <s:"string"> => {
    r.push(s);  p,new_words(r)
  },
};

Symbol: NodeRef = {
  BasicSymbol => p.new_sym(<>),
  "symbeg" "string_beg" <r:StringRep> <s:"string"> => {
    p.lstate = LexerState::END;
    r.push(s);
    p.new_dsym(r)
  },
};

BasicSymbol: Symbol = {
  "symbeg" <Sym> => { p.lstate = LexerState::END; <> },
};

Sym: Symbol = {
  Fname, "ivar", "gvar", "cvar",
  <"string"> => Symbol::from(<>),
  "string_beg" <"string"> => Symbol::from(<>),
};

Symbols: NodeRef = {
  "symbols_beg" <"string"> => p.new_symbols(vec![<>]),
  "symbols_beg" <r:StringRep> <s:"string"> => {
    r.push(s);
    p.new_symbols(r)
  },
};

Numeric: NodeRef = {
  "integer",
  "float",
  "uminus_num" <"integer"> // %prec "lowest"
    => p.negate_lit(<>),
  "uminus_num" <"float"> // %prec "lowest"
    => p.negate_lit(<>),
};

#[inline]
Variable: NodeRef = {
  "ident" => p.new_lvar(<>),
  "ivar" => p.new_lvar(<>),
  "gvar" => p.new_lvar(<>),
  "cvar" => p.new_lvar(<>),
  "const" => p.new_const(<>),
};

VarLhs: NodeRef = { Variable => p.assignable(<>) };

VarRef: NodeRef = {
  Variable => p.var_reference(<>),
  "nil" => p.new_nil(),
  "self" => p.new_self(),
  "true" => p.new_true(),
  "false" => p.new_false(),
  "__FILE__" => p.new_str(<>),
  "__LINE__" => p.new_int(<>),
};

Backref: NodeRef = { "nth_ref", "back_ref", };

Superclass: OptNodeRef = {
  Term => None,
  SuperclassSymbol <Expr> Term => <>,
};

SuperclassSymbol: () = {
  "<" => { p.lstate = LexerState::BEG; p.cmd_start = true; }
};

FArglist: NodeRef = {
  "(" <FArgs> Rparen => {
    p.lstate = LexerState::BEG;
    p.cmd_start = true;
    <>
  },
  <FArgs> Term => <>,
};

FArgs: NodeRef = {
  <pre:(<FArgItem> ",")*> <o:(<FOpt> ",")*> <r:FRestArg>
    <post:("," <FArgItem>)*> <post_opt:("," <FOpt>)*> <b:("," <FBlockArg>)?> =>
    p.new_args(pre, o, r, post, b),
  <pre:(<FArgItem> ",")*> <o:(FOpt ",")*> <o_last:FOpt> <b:("," <FBlockArg>)?> => {
    pre.push(last_pre);
    p.new_args(pre, o, None, vec![], b)
  },
  <pre:(<FArgItem> ",")*> <last_pre:FArgItem> <b:("," <FBlockArg>)?> => {
    pre.push(last_pre);
    p.new_args(pre, o, None, vec![], b)
  },
  FBlockArg? => p.new_args(vec![], vec![], None, vec![], <>)
};

// FBadArg: () = {
//   "const" => Err("formal argument cannot be a constant"),
//   "ivar" => Err("formal argument cannot be a instace variable"),
//   "gvar" => Err("formal argument cannot be a global variable"),
//   "cvar" => Err("formal argument cannot be a class variable"),
// };

FArgItem: NodeRef = {
  "ident" => p.new_arg(<>),
  "lparen" <FMargs> Rparen => p.new_masgn(<>, None),
};

#[inline]
FOpt: (Symbol, NodeRef) = {
  <o:"ident"> "=" <a:Arg> => {
    p.void_expr_error(a);
    (o, a)
  },
  // <o:FOptAsgn> <a:Primary>
};

RestargMark: () = { "*", "star" };

FRestArg: Option<Symbol> = {
  RestargMark <"ident"> => { p.local_add_f(<>); Some(<>) },
  RestargMark => { p.local_add_f(Symbol::from("*")); None },
};

BlkargMark: () = { "&", "amper" };

FBlockArg: Symbol = {
  BlkargMark <"ident"> => { p.local_add_f(<>); <> }
};

Singleton: NodeRef = {
  VarRef,
  SingletonParen <Expr> Rparen => match <>.node_type() => {
    NodeType::STR | NodeType::DXSTR | NodeType::XSTR | NodeType::DXSTR |
    NodeType::DREGX | NodeType::MATCH | NodeType::FLOAT | NodeType::ARRAY |
    NodeType::HEREDOR =>
      Err("Can't define singleton method of literals."),
    _ => <>,
  },
};

SingletonParen: () = { "(" => { p.lstate = LexerState::BEG; } };

Assoc: NodeRef = {
  <k:Arg> "=>" <v:Arg> => {
    p.void_expr_error(k);
    p.void_expr_error(v);
    (k, v)
  },
  <k:"label"> <v:Arg> => {
    p.void_expr_error(v);
    (p.new_sym(k), v)
  },
  <k:"label_end"> <v:Arg> => {
    p.void_expr_error(v);
    (p.new_sym(k), v)
  },
  "string_beg" <k:"label_end"> <v:Arg> => {
    p.void_expr_error(v);
    (p.new_sym(k), v)
  },
  "string_beg" <s:StringRep> <l:"label_end"> <v:Arg> => {
    p.void_expr_error(v);
    s.push(l);
    (p.new_dsym(s), v)
  },
};

Operation: Symbol = { "ident", "const", "fid" };
Operation2: Symbol = { "ident", "const", "fid", Op };
Operation3: Symbol = { "ident", "fid", Op };

DotOrColon: () = { ".", "colon2" };

CallOp: Symbol = {
  "." => Symbol::from("."),
  "&." => Symbol::from("&."),
};

CallOp2: Symbol = { CallOp, "colon2" };

Rparen: () = { Nl? ")" };
Rbracket: () = { Nl? "]" };

Trailer: () = { None, Nl, Comma };

Term: () = {
  ";", // => { yyerrok; }
  Nl,
  HeredocBody,
};

Nl: () = { "\n" => { p.lineno++; p.column = 0; } };

None: () = {};
