use ast::NodeRef;
use ast::OptNodeRef;
use ast::CpathType;
use lexer::Lexer;
use lexer::LexerState
use lexer::Tok;
use lalrpop_util::ParseError;

grammar<'state>(p: &mut Lexer<'state>);

extern {
  type Location = lexer::Location;
  type Error = lexer::LexerError;

  enum lexer::Tok<'input> {
    "alias" => Tok::Alias,
    "undef" => Tok::Undef,
    "BEGIN" => Tok::BEGIN,
    "END" => Tok::BEGIN,

    "{" => Tok::Char('{'),
    "}" => Tok::Char('}'),
    "=" => Tok::Char('='),
    "!" => Tok::Char('!'),
    "[" => Tok::Char('['),
    "]" => Tok::Char(']'),
    "," => Tok::Char(','),
    "|" => Tok::Char('|'),
    "^" => Tok::Char('^'),
    "&" => Tok::Char('&'),
    "<=>" => Tok::Cmp,
    "==" => Tok::Eq,
    "===" => Tok::Eqq,
    "=~" => Tok::Match,
    "!~" => Tok::NMatch,
    ">" => Tok::Char('>'),
    ">=" => Tok::GEq,
    "<" => Tok::Char('<'),
    "<=" => Tok::LEq,
    "!=" => Tok::NEq,
    "<<" => Tok::LShift,
    ">>" => Tok::RShift,
    "+" => Tok::Char('+'),
    "-" => Tok::Char('-'),
    "*" => Tok::Char('*'),
    "/" => Tok::Char('/'),
    "%" => Tok::Char('%'),
    "**" => Tok::Pow,
    "~" => Tok::Char('~'),
    "+@" => Tok::UPlus,
    "-@" => Tok::UMinus,
    "[]" => Tok::ARef,
    "[]=" => Tok::ASet,
    "`" => Tok::Char('`'),
    "&&" => Tok::AndOp,
    "||" => Tok::OrOp,
    "?" => Tok::Char('?'),
    ":" => Tok::Char(':'),
    "(" => Tok::Char('('),
    ")" => Tok::Char(')'),
    "amper" => Tok::Amper,
    "lparen_arg" => Tok::LparenArg,
    "lbrack" => Tok::Lbrack,
    "->" => Tok::Lambda,
    ";" => Tok::Char(';'),
    "=>" => Tok::Assoc,
    "." => Tok::Char('.'),
    "&." => Tok::AndDot,
    "\n" => Tok::NewLine,

    "lambeg" => Tok::Lambeg,

    "char" => Tok::Char(<String>),
    "string" => Tok::String(<String>),
    "string_beg" => Tok::StringBeg,
    "string_mid" => Tok::StringMid(<Symbol>),
    "string_part" => Tok::StringPart(<String>),
    "literal_delim" => Tok::LiteralDelim,
    "hd_literal_delim" => Tok::HdLiteralDelim,
    "xstring_beg" => Tok::XStringBeg,
    "xstring" => Tok::XString(<String>),
    "regexp_beg" => Tok::RegexpBeg,
    "regexp" => Tok::Regexp(<String>),
    "heredoc_beg" => Tok::HeredocBeg,
    "heredoc_end" => Tok::HeredocEnd,
    "hd_string_mid" => Tok::HdStringMid(<String>),
    "hd_start_part" => Tok::HdStartPart(<String>),
    "words_beg" => Tok::WordsBeg,
    "symbeg" => Tok::SymBeg,
    "symbols_beg" => Tok::SymbolsBeg,
    "label_end" => Tok::LabelEnd(<Symbol>),

    "nth_ref" => Tok::NthRef,
    "back_ref" => Tok::BackRef,

    "__LINE__" => Tok::Line,
    "__FILE__" => Tok::File,
    "__ENCODING__" => Tok::Encoding,

    "op_asgn" => Tok::op_asgn(<Symbol>),
    "ident" => Tok::Ident(<Symbol>),
    "fid" => Tok::FID(<Symbol>),
    "gvar" => Tok::GVar(<Symbol>),
    "ivar" => Tok::IVar(<Symbol>),
    "const" => Tok::Const(<Symbol>),
    "cvar" => Tok::CVar(<Symbol>),
    "label" => Tok::Label(<Symbol>),

    "uminus_num" => Tok::UMinusNum,
    "uplus" => Tok::UPlus,
    "uminus" => Tok::UMinus,
    "integer" => Tok::Integer(u32),
    "float" => Tok::Float(float),

    "colon2" => Tok::Colon2,
    "colon3" => Tok::Colon3,
    ".." => Tok::Dot2,
    "..." => Tok::Dot3,

    "mod_if" => Tok::ModifierIf,
    "mod_unless" => Tok::ModifierUnless,
    "mod_while" => Tok::ModifierWhile,
    "mod_until" => Tok::ModifierUntil,
    "mod_rescue" => Tok::ModifierRescue,

    "and" => Tok::And,
    "or" => Tok::Or,
    "not" => Tok::Not,
    "super" => Tok::Super,
    "yield" => Tok::Yield,
    "return" => Tok::Return,
    "break" => Tok::Break,
    "next" => Tok::Next,
    "begin" => Tok::Begin,
    "case" => Tok::Case,
    "class" => Tok::Class,
    "def" => Tok::Def,
    "do" => Tok::Do,
    "do_cond" => Tok::DoCond,
    "do_LAMBDA" => Tok::DoLambda,
    "do_block" => Tok::DoBlock,
    "else" => Tok::Else,
    "elsif" => Tok::Elsif,
    "end" => Tok::End,
    "ensure" => Tok::Ensure,
    "false" => Tok::False,
    "for" => Tok::For,
    "in" => Tok::In,
    "module" => Tok::Module,
    "nil" => Tok::Nil,
    "redo" => Tok::Redo,
    "rescue" => Tok::Rescue,
    "retry" => Tok::REtry,
    "self" => Tok::Self,
    "then" => Tok::Then,
    "true" => Tok::True,
    "undef" => Tok::Undef,
    "when" => Tok::When,
    "if" => Tok::If,
    "unless" => Tok::Unless,
    "while" => Tok::While,
    "until" => Tok::Until,

    "lbrace_arg" => Tok::LbraceArg,
    "star" => Tok::Star,
    "lparen" => Tok::Lparen,
  }
}

pub Program: NodeRef = { TopCompstmt };

TopCompstmt: NodeRef = { TopStmts };

TopStmts: BeginNodeRef = {
  None => p.new_begin(None),
  <t:TopStmt> => p.new_begin(Some(t)),
  <stmts:TopStmts> Term+ <t:TopStmt> Term* => { stmts.push(t); stmts },
  ! <t:TopStmt> => p.new_begin(None),
};

TopStmt: NodeRef = {
  Stmt,
  "BEGIN" "{" TopCompstmt "}" => Err("BEGIN not supported"),
};

Bodystmt: NodeRef = {
  <c:Compstmt> <r:OptRescue> <el:OptElse> <en:OptEnsure> =>
    p.new_bodystmt(c, r, el, en),
};

Compstmt: Vec<NodeRef> = { <Stmts> Term* => <> };

Stmts: Vec<NodeRef> = {
  None => vec![],
  Stmt => vec![<>],
  <res:Stmts> Term+ <s:Stmt> => { res.push(s); res },
  ! <s:Stmt> => vec![s],
};

StmtNoMod: NodeRef = {
  "alias" <a:AliasFsym> <f:Fsym> => p.new_alias(a, f),
  "undef" <l:UndefList> => p.new_undef(l),
  CommandAsgn,
  "END" "{" <s:Compstmt> "}" => Err("END not supported"),
  <l:Mlhs> "=" <c:CommandCall> => p.new_masgn(l, c),
  <l:Lhs> "=" <r:Mrhs> => p.new_asgn(l, p.new_array(r)),
  <l:Mlhs> "=" <a:Arg> => p.new_masgn(l, a),
  <l:Mlhs> "=" <r:Mrhs> => p.new_masgn(l, p.new_array(r)),
  Expr,
};

Stmt: NodeRef = {
  <s:StmtNoMod> "mod_if" <e:StmtNoMod> => p.new_if(p.cond(e) s, None),
  <s:StmtNoMod> "mod_unless" <e:StmtNoMod> => p.new_unless(p.cond(e), s, None),
  <s:StmtNoMod> "mod_while" <e:StmtNoMod> => p.new_while(p.cond(e), s),
  <s:StmtNoMod> "mod_until" <e:StmtNoMod> => p.new_until(p.cond(e), s),
  // <s:Stmt> "mod_rescue" <r:StmtNoMod> => p.new_mod_rescue(s, r),
  StmtNoMod,
};

AliasFsym: Symbol = {
  Fsym => { p.lstate = LexerState::FNAME; <> }
};

CommandAsgn: NodeRef = {
  <l:Lhs> "=" <r:CommandRhs> => p.new_asgn(l, r),
  <l:VarLhs> <op:"op_asgn"> <r:CommandRhs> => p.new_op_asgn(l, op, r),
  <prim:Primary> "[" <idx:OptCallArgs> Rbracket <op:"op_asgn"> <r:CommandRhs> =>
    p.new_op_asgn(p.new_call(prim, Symbol::from("[]"), idx, '.'), op, r),
  <prim:Primary> <c:CallOp> <id:"ident"> <op:"op_asgn"> <r:CommandRhs> =>
    p.new_op_asgn(p.new_call(prim, id, vec![], c), op, r),
  <prim:Primary> <c:CallOp> <id:"const"> <op:"op_asgn"> <r:CommandRhs> =>
    p.new_op_asgn(p.new_call(prim, id, vec![], c), op, r),
  Primary "colon2" "const" "op_asgn" CommandCall =>
    Err("constant re-assignment"),
  <prim:Primary> "colon2" <id:"ident"> <op:"op_asgn"> <r:CommandRhs> =>
    p.new_op_asgn(p.new_call(prim, id, vec![], Tok::colon2), op, r),
  <b:Backref> <op:"op_asgn"> CommandRhs => p.backref_error(b),
};

CommandRhs: NodeRef = {
  CommandCall, // %prec "op_asgn"
  <c:StmtNoMod> "mod_rescue" <s:CommandCall> => p.new_mod_rescue(c, s),
  CommandAsgn,
};

ExprNot: NodeRef = {
  "not" Nl? <e:Arg> => p.call_uni_op(p.cond(e), "!"),
};

ExprAndOr: NodeRef = {
  <l:ExprAndOr> "and" <r:ExprNot> => p.new_and(l, r),
  <l:ExprAndOr> "or" <r:ExprNot> => p.new_or(l, r),
  ExprNot,
};

Expr: NodeRef = {
  CommandCall,
  ExprAndOr,
  "!" <c:CommandCall> => p.call_uni_op(p.cond(c), "!"),
};

CommandCall: NodeRef = { Command, BlockCommand };

BlockCommand: NodeRef = {
  BlockCall,
  <b:BlockCall> <c:CallOp2> <o:Operation2> <args:CommandArgs> =>
    p.new_call(b, c, o, args),
};

CmdBraceBlock: NodeRef = {
  CmdBraceBlockBegin <b:OptBlockParam> <c:Compstmt> "}" => {
    let ret = p.new_block(b, c);
    p.local_unnest();
    ret
  }
};

CmdBraceBlockBegin: () = { "lbrace_arg" => p.local_nest() };

Command: NodeRef = {
  <op:Operation> <c:CommandArgs> => p.new_fcall(op, c), // %prec tLOWEST
  <op:Operation> <c:CommandArgs> <b:CmdBraceBlock> => {
    p.args_with_block(c, b);
    p.new_fcall(op, c)
  },
  <prim:Primary> <c_op:CallOp> <op:Operation2> <c:CommandArgs> => // %prec tLOWEST
    p.new_call(prim, op, c, c_op),
  <prim:Primary> <c_op:CallOp> <op:Operation2> <c:CommandArgs> <b:CmdBraceBlock> => {
    p.args_with_block(c, b);
    p.new_call(prim, op, c, c_op)
  },
  <prim:Primary> "colon2" <op:Operation2> <c:CommandArgs> => // %prec tLOWEST
    p.new_call(prim, op, c, Symbol::from("::")),
  <prim:Primary> "colon2" <op:Operation2> <c:CommandArgs> <b:CmdBraceBlock> => {
    p.args_with_block(c, b);
    p.new_call(prim, op, c, Symbol::from("::"))
  },
  "super" <c:CommandArgs> => p.new_super(c),
  "yield" <c:CommandArgs> => p.new_yield(c),
  "return" <c:CallArgs> => p.new_return(p.ret_args(c)),
  "break" <c:CallArgs> => p.new_break(p.ret_args(c)),
  "next" <c:CallArgs> => p.new_next(p.ret_args(c)),
};

Mlhs: Vec<NodeRef> = {
  MlhsBasic,
  "lparen" <MlhsInner> Rparen => <>,
};

MlhsInner: Vec<NodeRef> = {
  MlhsBasic,
  "lparen" <MlhsInner> Rparen => <>,
};

MlhsBasic: (Vec<NodeRef>, Option<OptNodeRef>, Vec<NodeRef>) = {
  MlhsHead => (<>, None, vec![]),
  <l:MlhsHead> <i:MlhsItem> => { l.push(i); (l, None, vec![]) },
  <l:MlhsHead> "star" <n:MlhsNode> => (l, Some(Some(n)), vec![]),
  <l:MlhsHead> "star" <n:MlhsNode> "," <post:MlhsPost> => (l, Some(Some(n)), post),
  <l:MlhsHead> "star" => (l, Some(None), vec![]),
  <l:MlhsHead> "star" "," <post:MlhsPost> => (l, Some(None), post),
  "star" <n:MlhsNode> => (vec![], Some(Some(n)), vec![]),
  "star" <n:MlhsNode> "," <post:MlhsPost> => (vec![], Some(Some(n)), post),
  "star" => (vec![], Some(None), vec![]),
  "star" "," <post:MlhsPost> => (vec![], Some(None), post),
};

MlhsItem: NodeRef = {
  MlhsNode,
  "lparen" <MlhsInner> Rparen => p.new_masgn(<>, vec![]),
};

MlhsHead: Vec<NodeRef> = {
  <MlhsItem> "," => vec![<>],
  <l:MlhsHead> <i:MlhsItem> "," => { l.push(i); l },
};

MlhsPost: Vec<NodeRef> = {
  MlhsItem => vec![<>],
  <l:MlhsPost> Comma <i:MlhsItem> => { l.push(i); l },
};

MlhsNode: NodeRef = { // lhs
  Variable => p.assignable(<>),
  <prim:Primary> "[" <c:OptCallArgs> Rbracket =>
    p.new_call(prim, Symbol::from(""), c, Symbol::from(".")),
  <prim:Primary> <c_op:CallOp> <id:"ident"> =>
    p.new_call(prim, id, vec![], c_op),
  <prim:Primary> "colon2" <id:"ident"> =>
    p.new_call(prim, id, vec![], Symbol::from("::")),
  <prim:Primary> <c_op:CallOp> <id:"const"> =>
    p.new_call(prim, id, vec![], c_op),
  <prim:Primary> "colon2" <id:"const"> => {
    if (p.in_def || p.in_single)
      return Err("dynamic constant assignment");
    p.new_colon2(prim, id, vec![], Symbol::from("::"))
  },
  "colon3" <id:"const"> => {
    if (p.in_def || p.in_single)
      return Err("dynamic constant assignment");
    p.new_colon3(id)
  },
  // <b:Backref> => p.backref_error(b)
};

Lhs: NodeRef = {
  Variable => p.assignable(<>),
  <prim:Primary> "[" <c:OptCallArgs> Rbracket =>
    p.new_call(prim, Symbol::from(""), c, Symbol::from(".")),
  <prim:Primary> <c_op:CallOp> <id:"ident"> =>
    p.new_call(prim, id, vec![], c_op),
  <prim:Primary> "colon2" <id:"ident"> =>
    p.new_call(prim, id, vec![], Symbol::from("::")),
  <prim:Primary> <c_op:CallOp> <id:"const"> =>
    p.new_call(prim, id, vec![], c_op),
  <prim:Primary> "colon2" <id:"const"> => {
    if (p.in_def || p.in_single)
      return Err("dynamic constant assignment");
    p.new_colon2(prim, id, vec![], Symbol::from("::"))
  },
  "colon3" <id:"const"> => {
    if (p.in_def || p.in_single)
      return Err("dynamic constant assignment");
    p.new_colon3(id)
  },
  <b:Backref> => p.backref_error(b)
};

Cname: Symbol = {
  "ident" => Err("class/module name must be CONSTANT"),
  "const",
};

Cpath: (CpathType, Symbol) = {
  "colon3" <Cname> => (Absolute, <>),
  Cname => (Relative, <>),
  <prim:Primary> "colon2" <c:Cname> => (Expression(prim), c),
};

Fname: Symbol = {
  "ident", "const", "fid",
  Op => { p.lstate = LexerState::ENDFN; <> },
  Reswords => {  p.lstate = LexerState::ENDFN; <> },
};

Fsym: Symbol = { Fname, BasicSymbol };

UndefList: Vec<Symbol> = {
  Fsym => vec![<>],
  <l:UndefList> UndefListComma <s:Fsym> => { l.push(s); l },
};

UndefListComma: () = { "," => { p.lstate = LexerState::FNAME; } };

Op: Symbol = {
  "|" => Symbol::from("|"),
  "^" => Symbol::from("^"),
  "&" => Symbol::from("&"),
  "<=>" => Symbol::from("<=>"),
  "==" => Symbol::from("=="),
  "===" => Symbol::from("==="),
  "=~" => Symbol::from("=~"),
  "!~" => Symbol::from("!~"),
  ">" => Symbol::from(">"),
  ">=" => Symbol::from(">="),
  "<" => Symbol::from("<"),
  "<=" => Symbol::from("<="),
  "!=" => Symbol::from("!="),
  "<<" => Symbol::from("<<"),
  ">>" => Symbol::from(">>"),
  "+" => Symbol::from("+"),
  "-" => Symbol::from("-"),
  "*" => Symbol::from("*"),
  "star" => Symbol::from("*"),
  "/" => Symbol::from("/"),
  "%" => Symbol::from("%"),
  "**" => Symbol::from("**"),
  "!" => Symbol::from("!"),
  "~" => Symbol::from("~"),
  "+@" => Symbol::from("+@"),
  "-@" => Symbol::from("-@"),
  "[]" => Symbol::from("[]"),
  "[]=" => Symbol::from("[]="),
  "`" => Symbol::from("`"),
};

Reswords: () = {
  "__LINE__", "__FILE__", "__ENCODING__", "BEGIN", "END",
  "alias", "and", "begin", "break", "case", "class", "def",
  "do", "else", "elsif", "end", "ensure", "false",
  "for", "in", "module", "next", "nil", "not", "or", "redo",
  "rescue", "retry", "return", "self",
  "super", "then", "true", "undef", "when", "yield", "if", "unless",
  "while", "until",
};

Arg1: NodeRef = {
  "!" <a:Primary> => p.call_uni_op(p.cond(a), "!"),
  "~" <a:Primary> => p.call_uni_op(p.cond(a), "~"),
  "uplus" <a:Primary> => p.call_uni_op(a, "+@"),
  Primary,
};

Arg2: NodeRef = {
  <l:Arg1> "**" <r:Arg2> => p.call_bin_op(l, "**", r),
  Arg1,
};

Arg3: NodeRef = {
  "uminus" <a:Arg2> => p.call_uni_op(a, "-@"),
  Arg2,
};

Arg4: NodeRef = {
  <l:Arg4> "*" <r:Arg3> => p.call_bin_op(l, "*", r),
  <l:Arg4> "/" <r:Arg3> => p.call_bin_op(l, "/", r),
  <l:Arg4> "%" <r:Arg3> => p.call_bin_op(l, "%", r),
  Arg3,
};

Arg5: NodeRef = {
  <l:Arg5> "+" <r:Arg4> => p.call_bin_op(l, "+", r),
  <l:Arg5> "-" <r:Arg4> => p.call_bin_op(l, "-", r),
  Arg4,
};

Arg6: NodeRef = {
  <l:Arg6> "<<" <r:Arg5> => p.call_bin_op(l, "<<", r),
  <l:Arg6> ">>" <r:Arg5> => p.call_bin_op(l, ">>", r),
  Arg5,
};

Arg7: NodeRef = {
  <l:Arg7> "&" <r:Arg6> => p.call_bin_op(l, "&", r),
  Arg6,
};

Arg8: NodeRef = {
  <l:Arg8> "|" <r:Arg7> => p.call_bin_op(l, "|", r),
  <l:Arg8> "^" <r:Arg7> => p.call_bin_op(l, "^", r),
  Arg7,
};

Arg9: NodeRef = {
  <l:Arg9> ">"  <r:Arg8> => p.call_bin_op(l, ">",  r),
  <l:Arg9> ">=" <r:Arg8> => p.call_bin_op(l, ">=", r),
  <l:Arg9> "<"  <r:Arg8> => p.call_bin_op(l, "<",  r),
  <l:Arg9> "<=" <r:Arg8> => p.call_bin_op(l, "<=", r),
  Arg8,
};

Arg10: NodeRef = {
  <l:Arg9> "<=>" <r:Arg9> => p.call_bin_op(l, "<=>", r),
  <l:Arg9> "==" <r:Arg9> => p.call_bin_op(l, "==", r),
  <l:Arg9> "===" <r:Arg9> => p.call_bin_op(l, "===", r),
  <l:Arg9> "!=" <r:Arg9> => p.call_bin_op(l, "!=", r),
  <l:Arg9> "=~" <r:Arg9> => p.call_bin_op(l, "=~", r),
  <l:Arg9> "!~" <r:Arg9> => p.call_bin_op(l, "!~", r),
  Arg9,
};

Arg11: NodeRef = {
  <l:Arg11> "&&" <r:Arg10> => p.new_and(l, r),
  Arg10,
};

Arg12: NodeRef = {
  <l:Arg12> "||" <r:Arg11> => p.new_or(l, r),
  Arg11,
};

Arg13: NodeRef = {
  <l:Arg12> ".." <r:Arg12> => p.new_dot2(l, r),
  <l:Arg12> "..." <r:Arg12> => p.new_dot3(l, r),
  Arg12,
};

Arg14: NodeRef = {
  <c:Arg13> "?" <t:Arg13> Nl? ":" <f:Arg13> => p.new_if(p.cond(c), t, f),
  Arg13,
};

ArgRhs: NodeRef = {
  Arg14, // %prec "op_asgn"
  <a:ArgRhs> "mod_rescue" <r:Arg14> => {
    p.void_expr_error(a);
    p.void_expr_error(r);
    p.new_mod_rescue(a, r)
  },
};

Arg: NodeRef = {
  <l:Lhs> "=" <r:ArgRhs> => p.new_asgn(l, r),
  <l:VarLhs> <op:"op_asgn"> <r:ArgRhs> => p.new_op_asgn(l, op, r),
  <prim:Primary> "[" <c:OptCallArgs> Rbracket <op:"op_asgn"> <r:ArgRhs> =>
    p.new_op_asgn(p.new_call(cprim, Symbol::from("[]")), op, r),
  <prim:Primary> <c_op:CallOp> <id:"ident"> <op:"op_asgn"> <r:ArgRhs> =>
    p.new_op_asgn(p.new_call(prim, id, vec![], c_op), op, r),
  <prim:Primary> <c_op:CallOp> <id:"const"> <op:"op_asgn"> <r:ArgRhs> =>
    p.new_op_asgn(p.new_call(prim, id, vec![], c_op), op, r),
  <prim:Primary> "colon2" <id:"ident"> <op:"op_asgn"> <r:ArgRhs> =>
    p.new_op_asgn(p.new_call(prim, id, vec![], Symbol::from("::"), op, r)),
  <prim:Primary> "colon2" <id:"const"> <op:"op_asgn"> <r:ArgRhs> =>
    Err("constant re-assignment"),
  "colon3" <id:"const"> <op:"op_asgn"> <r:ArgRhs> =>
    Err("constant re-assignment"),
  <b:Backref> <op:"op_asgn"> <r:Arg14> => p.backref_error(b),
  Arg14,
};

ArefArgs: Vec<NodeRef> = {
  None => vec![],
  <a:Args> Trailer => a,
  <a:Args> Comma <h:Assocs> Trailer => { a.push(p.new_hash(h)); a },
  <h:Assocs> Trailer => { vec![p.new_hash(h)] },
};

ParenArgs: Vec<NodeRef> = { "(" <OptCallArgs> Rparen => <> };

OptParenArgs: Vec<NodeRef> = {
  None => vec![],
  ParenArgs,
};

OptCallArgs: Vec<NodeRef> = {
  None => vec![],
  CallArgs,
  <Args> "," => <>,
  <a:Args> Comma <h:Assocs> "," => { a.push(p.new_hash(h)); a },
  <h:Assocs> "," => vec![p.new_hash(h), b],
};

CallArgs: Vec<NodeRef> = {
  Command => vec![<>],
  <a:Args> <b:OptBlockArg> => {
    match b { Some(b) => { a.push(b); }, _ => {} }; a
  },
  <h:Assocs> <b:OptBlockArg> =>
    match b { None => vec![p.new_hash(h)], Some(b) => vec![p.new_hash(h), b] },
  <a:Args> Comma <h:Assocs> <b:OptBlockArg> => {
    a.push(p.new_hash(h));
    match b { Some(b) => { a.push(b); }, _ => {} };
    a
  },
  BlockArg => vec![<>],
};

CommandArgs: Vec<NodeRef> = {
  // $<stack>$ = p.cmdarg_stack;
  // CMDARG_PUSH(1);
  CallArgs
  // p.cmdarg_stack = $<stack>1;
};

BlockArg: NodeRef = { "amper" <Arg> => p.new_block_arg(<>) };

OptBlockArg: OptNodeRef = {
  Comma <BlockArg> => Some(<>),
  None => None,
};

Comma: () = {
  "," => (),
  "," HeredocBodies => (),
};

Args: Vec<NodeRef> = {
  Arg => {
    p.void_expr_error(<>);
    vec![<>]
  },
  "star" <Arg> => {
    p.void_expr_error(<>);
    vec![p.new_splat(<>)]
  },
  <l:Args> Comma <a:Arg> => {
    p.void_expr_error(a);
    l.push(a); l
  },
  <l:Args> Comma "star" <a:Arg> => {
    p.void_expr_error(a);
    l.push(p.new_splat(a)); l
  },
};

Mrhs: Vec<NodeRef> = {
  <l:Args> Comma <a:Arg> => {
    p.void_expr_error(a);
    l.push(a); l
  },
  <l:Args> Comma "star" <a:Arg> => {
    p.void_expr_error(a);
    l.push(p.new_splat(a)); l
  },
  "star" <Arg> => {
    p.void_expr_error(<>);
    vec![p.new_splat(<>)]
  },
};

Primary: NodeRef = {
  Literal, String, Xstring, Regexp, Heredoc, VarRef, Backref,
  <"fid"> => p.new_fcall(<>, vec![]),
  "begin" // $<stack>$ = p.cmdarg_stack; p.cmdarg_stack = 0;
    <Bodystmt>
    "end" => <>, // p.cmdarg_stack = $<stack>2;
  "lparen_arg" // $<stck>$ = p.cmdarg_stack; p.cmdarg_stack = 0;
    <Stmt> // p.lstate = LexerState::ENDARG;
    Rparen => <>, // p.cmdarg_stack = $<stack>2;
  "lparen_arg" // p.lstate = LexerState::ENDARG;
    Rparen => p.new_nil(),
  "lparen" <Compstmt> "}" => <>,
  <prim:Primary> "colon2" <id:"const"> => p.new_colon2(prim, id),
  "colon3" <"const"> => p.new_colo3(<>),
  "lbrack" <ArefArgs> "]" => p.new_array(<>),
  "return" => p.new_return(vec![]),
  "yield" <OptParenArgs> => p.new_yield(<>),
  "not" "(" <Expr> Rparen => p.call_uni_op(p.cond(<>), "!"),
  "not" "(" Rparen => p.call_uni_op(p.new_nil(), "!"),
  <op:Operation> <b:BraceBlock> => p.new_fcall(op, b),
  MethodCall,
  <m:MethodCall> <b:BraceBlock> => { p.call_with_block(m, b); m },
  "->" // p.local_nest(); $<num>$ = p->lpar_beg; p.lpar_beg = ++p->paren_nest;
    <a:FLarglist> // $<stack>$ = p.cmdarg_stack; p.cmdarg_stack = 0;
    <b:LambdaBody> => {
      // p.lpar_beg = $<num>2;
      p.new_lambda(a, b)
      // p.local_unnest(); p.cmdarg_stack = $<stack>4; CMDARG_LEXPOP();
    },
  "if" <c:Expr> Then
    <s:Compstmt>
    <t:IfTail>
    "end" => p.new_if(p.cond(c), s, t),
  "unless" <c:Expr> Then
    <s:Compstmt>
    <e:OptElse>
    "end" => p.new_unless(p.cond(c), s, e),
  "while" // COND_PUSH(1);
    <c:Expr> Do // COND_POP();
    <s:Compstmt>
    <e:OptElse>
    "end" => p.new_while(p.cond(c), s, e),
  "until" // COND_PUSH(1);
    <c:Expr> Do // COND_POP();
    <s:Compstmt>
    <e:OptElse>
    "end" => p.new_until(p.cond(c), s, e),
  "case" <c:Expr> Term*
    <b:CaseBody>
    "end" => p.new_case(Some(c), b),
  "case" Term*
    <b:CaseBody>
    "end" => p.new_case(None(c), b),
  "for" <v:ForVar> "in" // COND_PUSH(1);
    <e:Expr> Do // COND_POP();
    <s:Compstmt>
    "end" => p.new_for(v, e, s),
  "class" <c:Cpath> <s:Superclass>
  // if p.in_def || p.in_single
  //   return Err("class definition in method body");
  // $<nd>$ = p.local_switch();
    <b:Bodystmt>
    "end" => {
      let ret = p.new_class(c, s, b);
      // p.local_resume($<nd>4);
      ret
    },
  "class" "<<" <c:Expr> // $<num>$ = p.in_def; p.in_def = 0;
    Term // $<nd>$ = cons(local_switch(p), nint(p.in_single)); p.in_single = 0;
    <s:Bodystmt>
    "end" => {
      let ret = p.new_sclass(c, s);
      // p.local_resume(p, $<nd>6->car);
      // p.in_def = $<num>4;
      // p.in_single = intn($<nd>6->cdr);
      ret
    },
  "module" <c:Cpath>
  // if p.in_def || p.in_single
  //   return Err("module definition in method body");
  // $<nd>$ = p.local_switch();
    <b:Bodystmt>
    "end" => {
      let ret = p.new_module(c, b);
      // p.local_resume($<nd>3);
      ret
    },
  "def" <f:Fname> // $<stack>$ = p.cmdarg_stack; p.cmdarg_stack = 0;
  // p.in_def++; $<nd>$ p.local_switch();
    <a:FArglist>
    <b:Bodystmt>
    "end" => {
      let ret = p.new_def(f, a, b);
      // p.local_resume(p, $<nd>4);
      // p.in_def--;
      // p.cmdarg_stack = $<stack>3;
      ret
    },
  "break" => p.new_break(vec![]),
  "next" => p.new_next(vec![]),
  "redo" => p.new_redo(),
  "retry" => p.new_retry(),
};

Then: () = { Term, "then", Term "then" };

Do: () = { Term, "do_cond" };

IfTail: OptNodeRef = {
  OptElse,
  "elsif" <c:Expr> Then
    <s:Compstmt>
    <t:IfTail> => Some(p.new_if(p.cond(c), s, t)),
};

OptElse: OptNodeRef = {
  None,
  "else" <Compstmt> => Some(<>)
};

ForVar: Vec<NodeRef> = { Lhs => vec![<>], Mlhs };

FMarg: NodeRef = {
  FNormArg => p.new_arg(<>),
  "lparen" <FMargs> Rparen => p.new_masgn(<>, vec![]),
};

FMargList: Vec<NodeRef> = {
  FMarg => vec![<>],
  <l:FMargList> "," <a:FMarg> => { l.push(a); l },
};

FMargs: (Vec<NodeRef>, Option<Option<NodeRef>>, Vec<NodeRef>) = {
  FMargList => (<>, None, vec![]),
  <l:FMargList> "," "star" <r:FNormArg> => (l, Some(Some(r)), vec![]),
  <l:FMargList> "," "star" <r:FNormArg> "," <p:FMargList> => (l, Some(Some(r)), p),
  <l:FMargList> "," "star" => (l, Some(None), vec![]),
  <l:FMargList> "," "star" "," <p:FMargList> => (l, Some(None), p),
  "star" <FNormArg> => (vec![], Some(<>), vec![]),
  "star" <r:FNormArg> "," <p:FMargList> => (vec![], Some(Some(r)), p),
  "star" => (vec![], Some(None), vec![]),
  "star" "," <p:FMargList> => (vec![], Some(None), p),
};

BlockParam: NodeRef = {
  <pre:FArg> "," <o:FBlockOptArg> "," <r:FRestArg> <b:OptFBlockArg> =>
    p.new_args(pre, o, r, vec![], b),
  <pre:FArg> "," <o:FBlockOptArg> "," <r:FRestArg> "," <post:FArg> <b:OptFBlockArg> =>
    p.new_args(pre, o, r, post, b),
  <pre:FArg> "," <o:FBlockOptArg> <b:OptFBlockArg> =>
    p.new_args(pre, o, None, vec![], b),
  <pre:FArg> "," <o:FBlockOptArg> "," <post:FArg> <b:OptFBlockArg> =>
    p.new_args(pre, o, None, post, b),
  <pre:FArg> "," <r:FRestArg> <b:OptFBlockArg> =>
    p.new_args(pre, vec![], r, vec![], b),
  <pre:FArg> "," => p.new_args(pre, vec![], None, vec![], None),
  <pre:FArg> "," <r:FRestArg> "," <post:FArg> <b:OptFBlockArg> =>
    p.new_args(pre, vec![], r, vec![] b),
  <o:FBlockOptArg> "," <r:FRestArg> <b:OptFBlockArg> =>
    p.new_args(vec![], o, r, vec![], b),
  <o:FBlockOptArg> "," <r:FRestArg> "," <post:FArg> <b:OptFBlockArg> =>
    p.new_args(vec![], o, r, post, b),
  <o:FBlockOptArg> <b:OptFBlockArg> =>
    p.new_args(vec![], o, None, vec![], b),
  <o:FBlockOptArg> "," <post:FArg> <b:OptFBlockArg> =>
    p.new_args(vec![], o, None, post, b),
  <r:FRestArg> <b:OptFBlockArg> =>
    p.new_args(vec![], vec![], None, vec![], b),
  <r:FRestArg> "," <post:FArg> <b:OptFBlockArg> =>
    p.new_args(vec![], vec![], r, post, b),
  <b:FBlockArg> => p.new_args(vec![], vec![], None, vec![], Some(b)),
};

OptBlockParam: OptNodeRef = {
  None => None,
  BlockParamDef => {
    p.cmd_start = TRUE;
    <>
  },
};

BlockParamDef: NodeRef = {
  "|" OptBvDecl "|" => None,
  "||" => None,
  "|" <BlockParam> OptBvDecl "|" => Some(<>),
};

OptBvDecl: () = { Nl?, Nl? ";" BvDecls Nl? };

BvDecls: () = { Bvar, BvDecls "," Bvar };

Bvar: () = {
  <"ident"> => {
    p.local_add_f(<>);
    p.new_bv(<>);
  },
  FBadArg,
};

FLarglist: Vec<NodeRef> = {
  "(" <FArgs> OptBvDecl ")" => <>,
  FArgs,
};

LambdaBody: NodeRef = {
  "lambeg" <Compstmt> "}" => <>,
  "do_LAMBDA" <Compstmt> "end" => <>,
};

DoBlock: NodeRef = {
  "do_block" // p.local_nest();
    <o:OptBlockParam>
    <s:Compstmt>
    "end" => {
      let ret = p.new_block(o, s);
      p.local_unnest();
      ret
    },
};

BlockCall: NodeRef = {
  <c:Command> <b:DoBlock> => {
    if (c.nd_type() == NodeType::YIELD) {
      return Err("block given to yield");
    }
    p.call_with_block(c, b)
  },
  <b:BlockCall> <c_op:CallOp2> <op:Operation2> <a:OptParenArgs> =>
    p.new_call(b, op, a, c_op),
  <b:BlockCall> <c_op:CallOp2> <op:Operation2> <a:OptParenArgs> <br:BraceBlock> =>
    p.call_with_block(p.new_call(b, op, a, c_op), br),
  <b:BlockCall> <c_op:CallOp2> <op:Operation2> <a:CommandArgs> <d:DoBlock> =>
    p.call_with_block(p.new_call(b, op, a, c_op), d),
};

MethodCall: NodeRef = {
  <op:Operation> <a:ParenArgs> => p.new_fcall(op, a),
  <prim:Primary> <c_op:CallOp> <op:Operation2> <a:OptParenArgs> =>
    p.new_call(prim, op, a, c_op),
  <prim:Primary> "colon2" <op:Operation2> <a:ParenArgs> =>
    p.new_call(prim, op, a, "::"),
  <prim:Primary> "colon2" <op:Operation3> =>
    p.new_call(prim, op, vec![], "::"),
  <prim:Primary> <c_op:CallOp> <a:ParenArgs> =>
    p.new_call(prim, Symbol::from("call"), a, c_op),
  <prim:Primary> "colon2" <a:ParenArgs> =>
    p.new_call(prim, Symbol::from("call"), a, "::"),
  "super" <ParenArgs> => p.new_super(<>),
  "super" => p.new_zsuper(),
  <prim:Primary> "[" <a:OptCallArgs> Rbracket =>
    p.new_call(prim, Symbol::from("[]"), a, "."),
};

BraceBlock: NodeRef = {
  "{" // p.local_nest(); $<num>$ = p.lineno;
    <param:OptBlockParam>
    <s:Compstmt> "}" => {
      let ret = p.new_block(param, s);
      p.local_unnest();
      ret
    },
  "do" // p.local_nest(); $<num>$ = p.lineno;
    <param:OptBlockParam>
    <s:Compstmt>
    "end" => {
      let ret = p.new_block(param, s);
      p.local_unnest();
      ret;
    },
};

CaseBody: (OptNodeRef, NodeRef, OptNodeRef) = {
  "when" <a:Args> Then
    <s:Compstmt>
    <c:Cases> => (Some(a), s, Some(c))
};

Cases: (OptNodeRef, NodeRef, OptNodeRef) = {
  OptElse => (None, s, None),
  CaseBody,
};

OptRescue: Option<(Vec<NodeRef>, OptNodeRef, NodeRef, OptNodeRef)> = {
  "rescue" <l:ExcList> <v:ExcVar> Then
    <s:Compstmt>
    <r:OptRescue> => (l, v, s, r),
  None => None,
};

ExcList: Vec<NodeRef> = {
  Arg => vec![<>],
  Mrhs,
  None, => vec![],
};

ExcVar: OptNodeRef = {
  "=>" <Lhs> => Some(<>),
  None => None,
};

OptEnsure: OptNodeRef = {
  "ensure" <Compstmt> => Some(<>),
  None => None,
};

Literal: NodeRef = { Numeric, Symbol, Words, Symbols, };

String: NodeRef = {
  "char", "string",
  "string_beg" <"string"> => <>,
  "string_beg" <r:StringRep> <s:"string"> => {
    r.push(s);
    p.new_dstr(r)
  },
};

StringRep: Vec<NodeRef> = {
  StringInterp,
  <r:StringRep> <s:StringInterp> => { r.append(s); r },
};

StringInterp: Vec<NodeRef> = {
  <"string_mid"> => vec![<>],
  <part:"string_part"> // $<nd>$ = p.lex_strterm; p.lex_strterm = None;
    <s:Compstmt> "}" => {
      p.lex_strterm = $<nd>2;
      vec![part, s],
    },
  "literal_delim" => vec![p.new_literal_delim()],
  "hd_literal_delim"  HeredocBodies => vec![p.new_literal_delim()],
};

Xstring: NodeRef = {
  "xstring_beg" <"xstring"> => <>,
  "xstring_beg" <r:StringRep> <s:"xstring"> => {
    r.push(s);
    p.new_dxstr(r)
  },
};

Regexp: NodeRef = {
  "regexp_beg" <"regexp"> => <>,
  "regexp_beg" <r:StringRep> <rgx:"regexp"> => p.new_dregx(r, rgx),
};

Heredoc: () = { "heredoc_beg" };

HeredocBodies: () = {
  HeredocBody,
  HeredocBodies HeredocBody => (),
};

HeredocBody: () = {
  "heredoc_end" => {
    let inf = p.parsing_hereodc_inf();
    inf.doc.push(p.new_str(""));
    p.heredoc_end();
  },
  HeredocStringRep "heredoc_end" => { p.heredoc_end(); },
};

HeredocStringRep: () = {
  HeredocStringInterp,
  HeredocStringRep HeredocStringInterp
};

HeredocStringInterp: () = {
  <"hd_string_mid"> => {
    let inf = p.parsing_heredoc_inf();
    inf.doc.push(p.new_str(<>));
    p.herdoc_treat_nextline();
  },
  <s:"hd_start_part"> // $<nd>$ = p.lex_strterm; p.lex_strterm = NULL;
    <c:Compstmt> "}" => {
      let inf = p.parsing_heredoc_inf();
      p.lex_strterm = $<nd>2;
      inf.doc.push(s);
      inf.doc.push(c);
    },
};

Words: NodeRef = {
  "words_beg" <"string"> => { p.new_words(vec![<>]) },
  "words_beg" <r:StringRep> <s:"string"> => {
    r.push(s);  p,new_words(r)
  },
};

Symbol: NodeRef = {
  BasicSymbol => p.new_sym(<>),
  "symbeg" "string_beg" <r:StringRep> <s:"string"> => {
    p.lstate = LexerState::END;
    r.push(s);
    p.new_dsym(r)
  },
};

BasicSymbol: Symbol = {
  "symbeg" <Sym> => { p.lstate = LexerState::END; <> },
};

Sym: Symbol = {
  Fname, "ivar", "gvar", "cvar",
  <"string"> => Symbol::from(<>),
  "string_beg" <"string"> => Symbol::from(<>),
};

Symbols: NodeRef = {
  "symbols_beg" <"string"> => p.new_symbols(vec![<>]),
  "symbols_beg" <r:StringRep> <s:"string"> => {
    r.push(s);
    p.new_symbols(r)
  },
};

Numeric: NodeRef = {
  "integer",
  "float",
  "uminus_num" <"integer"> // %prec "lowest"
    => p.negate_lit(<>),
  "uminus_num" <"float"> // %prec "lowest"
    => p.negate_lit(<>),
};

Variable: NodeRef = {
  <"ident"> => p.new_lvar(<>),
  <"ivar"> => p.new_lvar(<>),
  <"gvar"> => p.new_lvar(<>),
  <"cvar"> => p.new_lvar(<>),
  <"const"> => p.new_const(<>),
};

VarLhs: NodeRef = { Variable => p.assignable(<>) };

VarRef: NodeRef = {
  Variable => p.var_reference(<>),
  "nil" => p.new_nil(),
  "self" => p.new_self(),
  "true" => p.new_true(),
  "false" => p.new_false(),
  <"__FILE__"> => p.new_str(<>),
  <"__LINE__"> => p.new_int(<>),
};

Backref: NodeRef = { "nth_ref", "back_ref", };

Superclass: OptNodeRef = {
  Term => None,
  SuperclassSymbol <Expr> Term => <>,
};

SuperclassSymbol: () = {
  "<" => { p.lstate = LexerState::BEG; p.cmd_start = true; }
};

FArglist: NodeRef = {
  "(" <FArgs> Rparen => {
    p.lstate = LexerState::BEG;
    p.cmd_start = true;
    <>
  },
  <FArgs> Term => <>,
};

FArgs: NodeRef = {
  <pre:FArg> "," <o:FOptarg> "," <r:FRestArg> <b:OptFBlockArg> =>
    p.new_args(pre, o, Some(r), vec![], b),
  <pre:FArg> "," <o:FOptarg> "," <r:FRestArg> <post:FArg> <b:OptFBlockArg> =>
    p.new_args(pre, o, Some(r), post, b),
  <pre:FArg> "," <o:FOptarg> <b:OptFBlockArg> =>
    p.new_args(pre, o, None, vec![], b),
  <pre:FArg> "," <o:FOptarg> "," <post:FArg> <b:OptFBlockArg> =>
    p.new_args(pre, o, None, post, b),
  <pre:FArg> "," <r:FRestArg> <b:OptFBlockArg> =>
    p.new_args(pre, vec![], Some(r), vec![], b),
  <pre:FArg> "," <r:FRestArg> "," <post:FArg> <b:OptFBlockArg> =>
    p.new_args(pre, vec![], Some(r), post, b),
  <pre:FArg> <b:OptFBlockArg> => p.new_args(pre, vec![], None, vec![], b),
  <o:FOptarg> "," <r:FRestArg> <b:OptFBlockArg> =>
    p.new_args(vec![], o, Some(r), vec![], b),
  <o:FOptarg> "," <r:FRestArg> "," <post:FArg> <b:OptFBlockArg> =>
    p.new_args(vec![], o, Some(r), post, b),
  <o:FOptarg> <b:OptFBlockArg> => p.new_args(vec![], o, None, vec![], b),
  <o:FOptarg> "," <post:FArg> <b:OptFBlockArg> =>
    p.new_args(vec![], o, None, post, b),
  <r:FRestArg> <b:OptFBlockArg> => p.new_args(vec![], vec![], Some(r), vec![], b),
  <r:FRestArg> "," <post:FArg> <b:OptFBlockArg> =>
    p.new_args(vec![], vec![], Some(r), post, b),
  FBlockArg => p.new_args(vec![], vec![], None, vec![], b),
  None => {
    p.local_add_f(None);
    p.new_args(vec![], vec![], None, vec![], None)
  },
};

FBadArg: () = {
  "const" => Err("formal argument cannot be a constant"),
  "ivar" => Err("formal argument cannot be a instace variable"),
  "gvar" => Err("formal argument cannot be a global variable"),
  "cvar" => Err("formal argument cannot be a class variable"),
};

FNormArg: Symbol = {
  FBadArg,
  <"ident"> => {
    p.local_add_f(<>);
    <>
  },
};

FArgItem: NodeRef = {
  FNormArg => p.new_arg(<>),
  "lparen" <FMargs> Rparen => p.new_masgn(<>, None),
};

FArg: Vec<NodeRef> = {
  FArgItem => vec![<>],
  <l:FArg> "," <a:FArgItem> => { l.push(a); l },
};

FOptAsgn: Symbol = {
  <"ident"> "=" => { p.local_add_f(<>); <> },
};

FOpt: (Symbol, NodeRef) = {
  <o:FOptAsgn> <a:Arg> => {
    p.void_expr_error(a);
    (o, a)
  },
};

FBlockOpt: (Symbol, NodeRef) = {
  <o:FOptAsgn> <v:Primary> => {
    p.void_expr_error(v);
    (o, v)
  },
};

FBlockOptArg: Vec<(Symbol, NodeRef)> = {
  FBlockOpt => vec![<>],
  <l:FBlockOptArg> "," <b:FBlockOpt> => { l.push(b); l },
};

FOptarg: Vec<(Symbol, NodeRef)> = {
  FOpt => vec![<>],
  <l:FOptarg> "," <o:FOpt> => { l.push(o); l }
};

RestargMark: () = { "*", "star" };

FRestArg: Option<Symbol> = {
  RestargMark <"ident"> => { p.local_add_f(<>); Some(<>) },
  RestargMark => { p.local_add_f(Symbol::from("*")); None },
};

BlkargMark: () = { "&", "amper" };

FBlockArg: Symbol = {
  BlkargMark <"ident"> => { p.local_add_f(<>); <> }
};

OptFBlockArg: Option<Symbol> = {
  "," <FBlockArg> => <>,
  None => { p.local_add_f(Symbol::from("&")); None },
};

Singleton: NodeRef = {
  VarRef,
  SingletonParen <Expr> Rparen => match <>.node_type() => {
    NodeType::STR | NodeType::DXSTR | NodeType::XSTR | NodeType::DXSTR |
    NodeType::DREGX | NodeType::MATCH | NodeType::FLOAT | NodeType::ARRAY |
    NodeType::HEREDOR =>
      Err("Can't define singleton method of literals."),
    _ => <>,
  },
};

SingletonParen: () = { "(" => { p.lstate = LexerState::BEG; } };

AssocList: Vec<NodeRef> = {
  None => vec![],
  <Assocs> Trailer => <>,
};

Assocs: Vec<(NodeRef, NodeRef)> = {
  Assoc => vec![<>],
  <l:Assocs> "," <a:Assoc> => { l.push(a); l },
};

Assoc: NodeRef = {
  <k:Arg> "=>" <v:Arg> => {
    p.void_expr_error(k);
    p.void_expr_error(v);
    (k, v)
  },
  <k:"label"> <v:Arg> => {
    p.void_expr_error(v);
    (p.new_sym(k), v)
  },
  <k:"label_end"> <v:Arg> => {
    p.void_expr_error(v);
    (p.new_sym(k), v)
  },
  "string_beg" <k:"label_end"> <v:Arg> => {
    p.void_expr_error(v);
    (p.new_sym(k), v)
  },
  "string_beg" <s:StringRep> <l:"label_end"> <v:Arg> => {
    p.void_expr_error(v);
    s.push(l);
    (p.new_dsym(s), v)
  },
};

Operation: Symbol = { "ident", "const", "fid" };
Operation2: Symbol = { "ident", "const", "fid", Op };
Operation3: Symbol = { "ident", "fid", Op };

DotOrColon: () = { ".", "colon2" };

CallOp: Symbol = {
  "." => Symbol::from("."),
  "&." => Symbol::from("&."),
};

CallOp2: Symbol = { CallOp, "colon2" };

Rparen: () = { Nl? ")" };
Rbracket: () = { Nl? "]" };

Trailer: () = { None, Nl, Comma };

Term: () = {
  ";", // => { yyerrok; }
  Nl,
  HeredocBody,
};

Nl: () = { "\n" => { p.lineno++; p.column = 0; } };

None: () = {};
